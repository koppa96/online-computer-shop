/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.0.0 (NJsonSchema v10.3.0.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class BasketItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listItems(): Observable<BasketItemListResponse[]> {
        let url_ = this.baseUrl + "/api/webshop/basket-items";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListItems(<any>response_);
                } catch (e) {
                    return <Observable<BasketItemListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BasketItemListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListItems(response: HttpResponseBase): Observable<BasketItemListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BasketItemListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasketItemListResponse[]>(<any>null);
    }

    addItem(basketItemAddCommand: BasketItemAddCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/webshop/basket-items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(basketItemAddCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    removeItems(): Observable<void> {
        let url_ = this.baseUrl + "/api/webshop/basket-items";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItems(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveItems(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getItem(itemId: string): Observable<BasketItemGetResponse> {
        let url_ = this.baseUrl + "/api/webshop/basket-items/{itemId}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItem(<any>response_);
                } catch (e) {
                    return <Observable<BasketItemGetResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BasketItemGetResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetItem(response: HttpResponseBase): Observable<BasketItemGetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasketItemGetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasketItemGetResponse>(<any>null);
    }

    editItem(itemId: string, basketItemEditCommand: BasketItemEditCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/webshop/basket-items/{itemId}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(basketItemEditCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    removeItem(itemId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/webshop/basket-items/{itemId}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    addItems(items: BasketItemAddCommand[]): Observable<void> {
        let url_ = this.baseUrl + "/api/webshop/basket-items/multi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(items);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddItems(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddItems(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listCategories(): Observable<CategoryListResponse[]> {
        let url_ = this.baseUrl + "/api/webshop/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCategories(<any>response_);
                } catch (e) {
                    return <Observable<CategoryListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListCategories(response: HttpResponseBase): Observable<CategoryListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryListResponse[]>(<any>null);
    }

    listProducts(categoryId: string): Observable<ProductListResponse[]> {
        let url_ = this.baseUrl + "/api/webshop/Categories/{categoryId}/products";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListProducts(response: HttpResponseBase): Observable<ProductListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListResponse[]>(<any>null);
    }

    listProductsForComputerAssembler(categoryId: string, providedSockets: ProvidedSocketQuery[]): Observable<ComputerAssemblerProductListResponse[]> {
        let url_ = this.baseUrl + "/api/webshop/Categories/{categoryId}/computer-assembler-product-list";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(providedSockets);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListProductsForComputerAssembler(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListProductsForComputerAssembler(<any>response_);
                } catch (e) {
                    return <Observable<ComputerAssemblerProductListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComputerAssemblerProductListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListProductsForComputerAssembler(response: HttpResponseBase): Observable<ComputerAssemblerProductListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComputerAssemblerProductListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComputerAssemblerProductListResponse[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CommentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    editComment(commentId: string, commentEditCommand: CommentEditCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/webshop/Comments/{commentId}";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(commentEditCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    removeComment(commentId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/webshop/Comments/{commentId}";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listOrders(): Observable<OrderListResponse[]> {
        let url_ = this.baseUrl + "/api/webshop/Orders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListOrders(<any>response_);
                } catch (e) {
                    return <Observable<OrderListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListOrders(response: HttpResponseBase): Observable<OrderListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderListResponse[]>(<any>null);
    }

    createOrder(orderCreateCommand: OrderCreateCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/webshop/Orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orderCreateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getOrder(orderId: string): Observable<OrderGetResponse> {
        let url_ = this.baseUrl + "/api/webshop/Orders/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrder(<any>response_);
                } catch (e) {
                    return <Observable<OrderGetResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderGetResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrder(response: HttpResponseBase): Observable<OrderGetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderGetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderGetResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getProduct(productId: string): Observable<ProductGetResponse> {
        let url_ = this.baseUrl + "/api/webshop/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductGetResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductGetResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetProduct(response: HttpResponseBase): Observable<ProductGetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductGetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductGetResponse>(<any>null);
    }

    createComment(productId: string, commentCreateCommand: CommentCreateCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/webshop/Products/{productId}/comments";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(commentCreateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class BasketItemListResponse implements IBasketItemListResponse {
    id?: string;
    productId?: string;
    categoryId?: string;
    categoryName?: string | undefined;
    productName?: string | undefined;
    quantity?: number;
    pricePerPiece?: number;

    constructor(data?: IBasketItemListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.pricePerPiece = _data["pricePerPiece"];
        }
    }

    static fromJS(data: any): BasketItemListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BasketItemListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["pricePerPiece"] = this.pricePerPiece;
        return data; 
    }
}

export interface IBasketItemListResponse {
    id?: string;
    productId?: string;
    categoryId?: string;
    categoryName?: string | undefined;
    productName?: string | undefined;
    quantity?: number;
    pricePerPiece?: number;
}

export class BasketItemGetResponse implements IBasketItemGetResponse {
    id?: string;
    productId?: string;
    productName?: string | undefined;
    quantity?: number;
    pricePerPiece?: number;

    constructor(data?: IBasketItemGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.pricePerPiece = _data["pricePerPiece"];
        }
    }

    static fromJS(data: any): BasketItemGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BasketItemGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["pricePerPiece"] = this.pricePerPiece;
        return data; 
    }
}

export interface IBasketItemGetResponse {
    id?: string;
    productId?: string;
    productName?: string | undefined;
    quantity?: number;
    pricePerPiece?: number;
}

export class BasketItemAddCommand implements IBasketItemAddCommand {
    productId?: string;
    quantity?: number;

    constructor(data?: IBasketItemAddCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): BasketItemAddCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BasketItemAddCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        return data; 
    }
}

export interface IBasketItemAddCommand {
    productId?: string;
    quantity?: number;
}

export class BasketItemEditCommand implements IBasketItemEditCommand {
    id?: string;
    productId?: string;
    quantity?: number;

    constructor(data?: IBasketItemEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): BasketItemEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BasketItemEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        return data; 
    }
}

export interface IBasketItemEditCommand {
    id?: string;
    productId?: string;
    quantity?: number;
}

export class CategoryListResponse implements ICategoryListResponse {
    id?: string;
    name?: string | undefined;

    constructor(data?: ICategoryListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategoryListResponse {
    id?: string;
    name?: string | undefined;
}

export class ProductListResponse implements IProductListResponse {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;

    constructor(data?: IProductListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): ProductListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        return data; 
    }
}

export interface IProductListResponse {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
}

export class ComputerAssemblerProductListResponse implements IComputerAssemblerProductListResponse {
    id?: string;
    name?: string | undefined;
    pricePerPiece?: number;
    productSockets?: ProductSocketResponse[] | undefined;

    constructor(data?: IComputerAssemblerProductListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.pricePerPiece = _data["pricePerPiece"];
            if (Array.isArray(_data["productSockets"])) {
                this.productSockets = [] as any;
                for (let item of _data["productSockets"])
                    this.productSockets!.push(ProductSocketResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ComputerAssemblerProductListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ComputerAssemblerProductListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["pricePerPiece"] = this.pricePerPiece;
        if (Array.isArray(this.productSockets)) {
            data["productSockets"] = [];
            for (let item of this.productSockets)
                data["productSockets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IComputerAssemblerProductListResponse {
    id?: string;
    name?: string | undefined;
    pricePerPiece?: number;
    productSockets?: ProductSocketResponse[] | undefined;
}

export class ProductSocketResponse implements IProductSocketResponse {
    socketId?: string;
    socketName?: string | undefined;
    providesUses?: ProvidesUses;
    numberOfSocket?: number;

    constructor(data?: IProductSocketResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socketId = _data["socketId"];
            this.socketName = _data["socketName"];
            this.providesUses = _data["providesUses"];
            this.numberOfSocket = _data["numberOfSocket"];
        }
    }

    static fromJS(data: any): ProductSocketResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSocketResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socketId"] = this.socketId;
        data["socketName"] = this.socketName;
        data["providesUses"] = this.providesUses;
        data["numberOfSocket"] = this.numberOfSocket;
        return data; 
    }
}

export interface IProductSocketResponse {
    socketId?: string;
    socketName?: string | undefined;
    providesUses?: ProvidesUses;
    numberOfSocket?: number;
}

export enum ProvidesUses {
    Provides = 0,
    Uses = 1,
}

export class ProvidedSocketQuery implements IProvidedSocketQuery {
    socketId?: string;
    numberOfSocket?: number;

    constructor(data?: IProvidedSocketQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socketId = _data["socketId"];
            this.numberOfSocket = _data["numberOfSocket"];
        }
    }

    static fromJS(data: any): ProvidedSocketQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ProvidedSocketQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socketId"] = this.socketId;
        data["numberOfSocket"] = this.numberOfSocket;
        return data; 
    }
}

export interface IProvidedSocketQuery {
    socketId?: string;
    numberOfSocket?: number;
}

export class CommentEditCommand implements ICommentEditCommand {
    id?: string;
    text?: string | undefined;
    rating?: number;

    constructor(data?: ICommentEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.rating = _data["rating"];
        }
    }

    static fromJS(data: any): CommentEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CommentEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["rating"] = this.rating;
        return data; 
    }
}

export interface ICommentEditCommand {
    id?: string;
    text?: string | undefined;
    rating?: number;
}

export class OrderListResponse implements IOrderListResponse {
    id?: string;
    state?: OrderState;
    dateTimeOfOrder?: Date;

    constructor(data?: IOrderListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.dateTimeOfOrder = _data["dateTimeOfOrder"] ? new Date(_data["dateTimeOfOrder"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["dateTimeOfOrder"] = this.dateTimeOfOrder ? this.dateTimeOfOrder.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOrderListResponse {
    id?: string;
    state?: OrderState;
    dateTimeOfOrder?: Date;
}

export enum OrderState {
    Unsent = 0,
    Sent = 1,
    Paid = 2,
}

export class OrderGetResponse implements IOrderGetResponse {
    id?: string;
    userName?: string | undefined;
    address?: string | undefined;
    state?: OrderState;
    dateTimeOfOrder?: Date;
    orderItems?: OrderItemGetResponse[] | undefined;

    constructor(data?: IOrderGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.address = _data["address"];
            this.state = _data["state"];
            this.dateTimeOfOrder = _data["dateTimeOfOrder"] ? new Date(_data["dateTimeOfOrder"].toString()) : <any>undefined;
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItemGetResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["address"] = this.address;
        data["state"] = this.state;
        data["dateTimeOfOrder"] = this.dateTimeOfOrder ? this.dateTimeOfOrder.toISOString() : <any>undefined;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderGetResponse {
    id?: string;
    userName?: string | undefined;
    address?: string | undefined;
    state?: OrderState;
    dateTimeOfOrder?: Date;
    orderItems?: OrderItemGetResponse[] | undefined;
}

export class OrderItemGetResponse implements IOrderItemGetResponse {
    id?: string;
    categoryId?: string;
    productId?: string;
    productName?: string | undefined;
    quantity?: number;
    pricePerPiece?: number;

    constructor(data?: IOrderItemGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.pricePerPiece = _data["pricePerPiece"];
        }
    }

    static fromJS(data: any): OrderItemGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["pricePerPiece"] = this.pricePerPiece;
        return data; 
    }
}

export interface IOrderItemGetResponse {
    id?: string;
    categoryId?: string;
    productId?: string;
    productName?: string | undefined;
    quantity?: number;
    pricePerPiece?: number;
}

export class OrderCreateCommand implements IOrderCreateCommand {
    name?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;

    constructor(data?: IOrderCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): OrderCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        return data; 
    }
}

export interface IOrderCreateCommand {
    name?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
}

export class ProductGetResponse implements IProductGetResponse {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    categoryId?: string;
    category?: string | undefined;
    propertyValues?: PropertyValueResponse[] | undefined;
    productSockets?: ProductSocketResponse2[] | undefined;
    comments?: CommentResponse[] | undefined;

    constructor(data?: IProductGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"];
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValueResponse.fromJS(item));
            }
            if (Array.isArray(_data["productSockets"])) {
                this.productSockets = [] as any;
                for (let item of _data["productSockets"])
                    this.productSockets!.push(ProductSocketResponse2.fromJS(item));
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category;
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        if (Array.isArray(this.productSockets)) {
            data["productSockets"] = [];
            for (let item of this.productSockets)
                data["productSockets"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductGetResponse {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    categoryId?: string;
    category?: string | undefined;
    propertyValues?: PropertyValueResponse[] | undefined;
    productSockets?: ProductSocketResponse2[] | undefined;
    comments?: CommentResponse[] | undefined;
}

export class PropertyValueResponse implements IPropertyValueResponse {
    propertyTypeId?: string;
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IPropertyValueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyTypeId = _data["propertyTypeId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyTypeId"] = this.propertyTypeId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface IPropertyValueResponse {
    propertyTypeId?: string;
    name?: string | undefined;
    value?: string | undefined;
}

export class ProductSocketResponse2 implements IProductSocketResponse2 {
    socketId?: string;
    name?: string | undefined;
    providesUses?: ProvidesUses;
    numberOfSocket?: number;

    constructor(data?: IProductSocketResponse2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socketId = _data["socketId"];
            this.name = _data["name"];
            this.providesUses = _data["providesUses"];
            this.numberOfSocket = _data["numberOfSocket"];
        }
    }

    static fromJS(data: any): ProductSocketResponse2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSocketResponse2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socketId"] = this.socketId;
        data["name"] = this.name;
        data["providesUses"] = this.providesUses;
        data["numberOfSocket"] = this.numberOfSocket;
        return data; 
    }
}

export interface IProductSocketResponse2 {
    socketId?: string;
    name?: string | undefined;
    providesUses?: ProvidesUses;
    numberOfSocket?: number;
}

export class CommentResponse implements ICommentResponse {
    id?: string;
    text?: string | undefined;
    rating?: number | undefined;
    userName?: string | undefined;
    dateTimeOfCreation?: Date;

    constructor(data?: ICommentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.rating = _data["rating"];
            this.userName = _data["userName"];
            this.dateTimeOfCreation = _data["dateTimeOfCreation"] ? new Date(_data["dateTimeOfCreation"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CommentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["rating"] = this.rating;
        data["userName"] = this.userName;
        data["dateTimeOfCreation"] = this.dateTimeOfCreation ? this.dateTimeOfCreation.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICommentResponse {
    id?: string;
    text?: string | undefined;
    rating?: number | undefined;
    userName?: string | undefined;
    dateTimeOfCreation?: Date;
}

export class CommentCreateCommand implements ICommentCreateCommand {
    productId?: string;
    text?: string | undefined;
    rating?: number;

    constructor(data?: ICommentCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.text = _data["text"];
            this.rating = _data["rating"];
        }
    }

    static fromJS(data: any): CommentCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CommentCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["text"] = this.text;
        data["rating"] = this.rating;
        return data; 
    }
}

export interface ICommentCreateCommand {
    productId?: string;
    text?: string | undefined;
    rating?: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}