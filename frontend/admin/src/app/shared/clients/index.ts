/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.0.0 (NJsonSchema v10.3.0.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AdministratorsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listAdministrators(): Observable<AdministratorListResponse[]> {
        let url_ = this.baseUrl + "/api/admin/Administrators";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAdministrators(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAdministrators(<any>response_);
                } catch (e) {
                    return <Observable<AdministratorListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdministratorListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListAdministrators(response: HttpResponseBase): Observable<AdministratorListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdministratorListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdministratorListResponse[]>(<any>null);
    }

    createAdministrator(): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Administrators";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAdministrator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAdministrator(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAdministrator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    removeAdministrator(administratorId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Administrators/{administratorId}";
        if (administratorId === undefined || administratorId === null)
            throw new Error("The parameter 'administratorId' must be defined.");
        url_ = url_.replace("{administratorId}", encodeURIComponent("" + administratorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAdministrator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAdministrator(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAdministrator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listCategories(): Observable<CategoryListResponse[]> {
        let url_ = this.baseUrl + "/api/admin/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCategories(<any>response_);
                } catch (e) {
                    return <Observable<CategoryListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListCategories(response: HttpResponseBase): Observable<CategoryListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryListResponse[]>(<any>null);
    }

    createCategory(categoryCreateCommand: CategoryCreateCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(categoryCreateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getCategory(categoryId: string): Observable<CategoryGetResponse> {
        let url_ = this.baseUrl + "/api/admin/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategory(<any>response_);
                } catch (e) {
                    return <Observable<CategoryGetResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryGetResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategory(response: HttpResponseBase): Observable<CategoryGetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryGetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryGetResponse>(<any>null);
    }

    editCategory(categoryId: string, categoryEditCommand: CategoryEditCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(categoryEditCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    removeCategory(categoryId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    listProducts(categoryId: string, socketIds: string[] | null | undefined): Observable<ProductListResponse[]> {
        let url_ = this.baseUrl + "/api/admin/Categories/{categoryId}/products?";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        if (socketIds !== undefined && socketIds !== null)
            socketIds && socketIds.forEach(item => { url_ += "socketIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListProducts(response: HttpResponseBase): Observable<ProductListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListResponse[]>(<any>null);
    }

    createProduct(categoryId: string, productCreateCommand: ProductCreateCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Categories/{categoryId}/products";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(productCreateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CommentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    removeComment(commentId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Comments/{commentId}";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listOrders(userName: string | null | undefined): Observable<OrderListResponse[]> {
        let url_ = this.baseUrl + "/api/admin/Orders?";
        if (userName !== undefined && userName !== null)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListOrders(<any>response_);
                } catch (e) {
                    return <Observable<OrderListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListOrders(response: HttpResponseBase): Observable<OrderListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderListResponse[]>(<any>null);
    }

    getOrder(orderId: string): Observable<OrderGetResponse> {
        let url_ = this.baseUrl + "/api/admin/Orders/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrder(<any>response_);
                } catch (e) {
                    return <Observable<OrderGetResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderGetResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrder(response: HttpResponseBase): Observable<OrderGetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderGetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderGetResponse>(<any>null);
    }

    removeOrder(orderId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Orders/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    editOrderState(orderId: string, orderStateEditCommand: OrderStateEditCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Orders/{orderId}/state";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orderStateEditCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOrderState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOrderState(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditOrderState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    editOrderAddress(orderId: string, orderAddressEditCommand: OrderAddressEditCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Orders/{orderId}/address";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orderAddressEditCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOrderAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOrderAddress(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditOrderAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getProduct(productId: string): Observable<ProductGetResponse> {
        let url_ = this.baseUrl + "/api/admin/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductGetResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductGetResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetProduct(response: HttpResponseBase): Observable<ProductGetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductGetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductGetResponse>(<any>null);
    }

    editProduct(productId: string, productEditCommand: ProductEditCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(productEditCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProduct(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    removeProduct(productId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveProduct(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SocketsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createSocket(socketCreateCommand: SocketCreateCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Sockets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(socketCreateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSocket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSocket(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSocket(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    listSockets(): Observable<SocketListResponse[]> {
        let url_ = this.baseUrl + "/api/admin/Sockets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListSockets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListSockets(<any>response_);
                } catch (e) {
                    return <Observable<SocketListResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SocketListResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processListSockets(response: HttpResponseBase): Observable<SocketListResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocketListResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SocketListResponse[]>(<any>null);
    }

    getSocket(socketId: string): Observable<SocketGetResponse> {
        let url_ = this.baseUrl + "/api/admin/Sockets/{socketId}";
        if (socketId === undefined || socketId === null)
            throw new Error("The parameter 'socketId' must be defined.");
        url_ = url_.replace("{socketId}", encodeURIComponent("" + socketId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSocket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSocket(<any>response_);
                } catch (e) {
                    return <Observable<SocketGetResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SocketGetResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSocket(response: HttpResponseBase): Observable<SocketGetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SocketGetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SocketGetResponse>(<any>null);
    }

    removeSocket(socketId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/Sockets/{socketId}";
        if (socketId === undefined || socketId === null)
            throw new Error("The parameter 'socketId' must be defined.");
        url_ = url_.replace("{socketId}", encodeURIComponent("" + socketId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveSocket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveSocket(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveSocket(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class AdministratorListResponse implements IAdministratorListResponse {
    id?: string;
    userName?: string | undefined;

    constructor(data?: IAdministratorListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): AdministratorListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdministratorListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IAdministratorListResponse {
    id?: string;
    userName?: string | undefined;
}

export class CategoryListResponse implements ICategoryListResponse {
    id?: string;
    name?: string | undefined;

    constructor(data?: ICategoryListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategoryListResponse {
    id?: string;
    name?: string | undefined;
}

export class CategoryGetResponse implements ICategoryGetResponse {
    id?: string;
    name?: string | undefined;
    propertyTypes?: PropertyTypeGetResponse[] | undefined;
    categorySockets?: CategorySocketGetResponse[] | undefined;

    constructor(data?: ICategoryGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["propertyTypes"])) {
                this.propertyTypes = [] as any;
                for (let item of _data["propertyTypes"])
                    this.propertyTypes!.push(PropertyTypeGetResponse.fromJS(item));
            }
            if (Array.isArray(_data["categorySockets"])) {
                this.categorySockets = [] as any;
                for (let item of _data["categorySockets"])
                    this.categorySockets!.push(CategorySocketGetResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.propertyTypes)) {
            data["propertyTypes"] = [];
            for (let item of this.propertyTypes)
                data["propertyTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.categorySockets)) {
            data["categorySockets"] = [];
            for (let item of this.categorySockets)
                data["categorySockets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICategoryGetResponse {
    id?: string;
    name?: string | undefined;
    propertyTypes?: PropertyTypeGetResponse[] | undefined;
    categorySockets?: CategorySocketGetResponse[] | undefined;
}

export class PropertyTypeGetResponse implements IPropertyTypeGetResponse {
    id?: string;
    name?: string | undefined;

    constructor(data?: IPropertyTypeGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PropertyTypeGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyTypeGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPropertyTypeGetResponse {
    id?: string;
    name?: string | undefined;
}

export class CategorySocketGetResponse implements ICategorySocketGetResponse {
    socketId?: string;
    socketName?: string | undefined;

    constructor(data?: ICategorySocketGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socketId = _data["socketId"];
            this.socketName = _data["socketName"];
        }
    }

    static fromJS(data: any): CategorySocketGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySocketGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socketId"] = this.socketId;
        data["socketName"] = this.socketName;
        return data; 
    }
}

export interface ICategorySocketGetResponse {
    socketId?: string;
    socketName?: string | undefined;
}

export class CategoryCreateCommand implements ICategoryCreateCommand {
    name?: string | undefined;
    propertyTypes?: string[] | undefined;
    socketIds?: string[] | undefined;

    constructor(data?: ICategoryCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["propertyTypes"])) {
                this.propertyTypes = [] as any;
                for (let item of _data["propertyTypes"])
                    this.propertyTypes!.push(item);
            }
            if (Array.isArray(_data["socketIds"])) {
                this.socketIds = [] as any;
                for (let item of _data["socketIds"])
                    this.socketIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CategoryCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.propertyTypes)) {
            data["propertyTypes"] = [];
            for (let item of this.propertyTypes)
                data["propertyTypes"].push(item);
        }
        if (Array.isArray(this.socketIds)) {
            data["socketIds"] = [];
            for (let item of this.socketIds)
                data["socketIds"].push(item);
        }
        return data; 
    }
}

export interface ICategoryCreateCommand {
    name?: string | undefined;
    propertyTypes?: string[] | undefined;
    socketIds?: string[] | undefined;
}

export class CategoryEditCommand implements ICategoryEditCommand {
    id?: string;
    name?: string | undefined;
    propertyTypes?: PropertyTypeEditCommand[] | undefined;
    categorySockets?: CategorySocketEditCommand[] | undefined;

    constructor(data?: ICategoryEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["propertyTypes"])) {
                this.propertyTypes = [] as any;
                for (let item of _data["propertyTypes"])
                    this.propertyTypes!.push(PropertyTypeEditCommand.fromJS(item));
            }
            if (Array.isArray(_data["categorySockets"])) {
                this.categorySockets = [] as any;
                for (let item of _data["categorySockets"])
                    this.categorySockets!.push(CategorySocketEditCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.propertyTypes)) {
            data["propertyTypes"] = [];
            for (let item of this.propertyTypes)
                data["propertyTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.categorySockets)) {
            data["categorySockets"] = [];
            for (let item of this.categorySockets)
                data["categorySockets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICategoryEditCommand {
    id?: string;
    name?: string | undefined;
    propertyTypes?: PropertyTypeEditCommand[] | undefined;
    categorySockets?: CategorySocketEditCommand[] | undefined;
}

export class PropertyTypeEditCommand implements IPropertyTypeEditCommand {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IPropertyTypeEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PropertyTypeEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyTypeEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPropertyTypeEditCommand {
    id?: string | undefined;
    name?: string | undefined;
}

export class CategorySocketEditCommand implements ICategorySocketEditCommand {
    socketId?: string;

    constructor(data?: ICategorySocketEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socketId = _data["socketId"];
        }
    }

    static fromJS(data: any): CategorySocketEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySocketEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socketId"] = this.socketId;
        return data; 
    }
}

export interface ICategorySocketEditCommand {
    socketId?: string;
}

export class ProductListResponse implements IProductListResponse {
    id?: string;
    name?: string | undefined;

    constructor(data?: IProductListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProductListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProductListResponse {
    id?: string;
    name?: string | undefined;
}

export class ProductCreateCommand implements IProductCreateCommand {
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    categoryId?: string;
    propertyValues?: PropertyValueCreateCommand[] | undefined;
    productSockets?: ProductSocketCreateCommand[] | undefined;

    constructor(data?: IProductCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValueCreateCommand.fromJS(item));
            }
            if (Array.isArray(_data["productSockets"])) {
                this.productSockets = [] as any;
                for (let item of _data["productSockets"])
                    this.productSockets!.push(ProductSocketCreateCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        if (Array.isArray(this.productSockets)) {
            data["productSockets"] = [];
            for (let item of this.productSockets)
                data["productSockets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductCreateCommand {
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    categoryId?: string;
    propertyValues?: PropertyValueCreateCommand[] | undefined;
    productSockets?: ProductSocketCreateCommand[] | undefined;
}

export class PropertyValueCreateCommand implements IPropertyValueCreateCommand {
    propertyTypeId?: string;
    value?: string | undefined;

    constructor(data?: IPropertyValueCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyTypeId = _data["propertyTypeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyValueCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValueCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyTypeId"] = this.propertyTypeId;
        data["value"] = this.value;
        return data; 
    }
}

export interface IPropertyValueCreateCommand {
    propertyTypeId?: string;
    value?: string | undefined;
}

export class ProductSocketCreateCommand implements IProductSocketCreateCommand {
    socketId?: string;

    constructor(data?: IProductSocketCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socketId = _data["socketId"];
        }
    }

    static fromJS(data: any): ProductSocketCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSocketCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socketId"] = this.socketId;
        return data; 
    }
}

export interface IProductSocketCreateCommand {
    socketId?: string;
}

export class OrderListResponse implements IOrderListResponse {
    id?: string;
    userName?: string | undefined;
    state?: OrderState;
    dateTimeOfOrder?: Date;

    constructor(data?: IOrderListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.state = _data["state"];
            this.dateTimeOfOrder = _data["dateTimeOfOrder"] ? new Date(_data["dateTimeOfOrder"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["state"] = this.state;
        data["dateTimeOfOrder"] = this.dateTimeOfOrder ? this.dateTimeOfOrder.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOrderListResponse {
    id?: string;
    userName?: string | undefined;
    state?: OrderState;
    dateTimeOfOrder?: Date;
}

export enum OrderState {
    Unsent = 0,
    Sent = 1,
    Paid = 2,
}

export class OrderGetResponse implements IOrderGetResponse {
    userName?: string;
    address?: string | undefined;
    state?: OrderState;
    dateTimeOfOrder?: Date;
    orderItems?: OrderItemGetResponse[] | undefined;

    constructor(data?: IOrderGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.address = _data["address"];
            this.state = _data["state"];
            this.dateTimeOfOrder = _data["dateTimeOfOrder"] ? new Date(_data["dateTimeOfOrder"].toString()) : <any>undefined;
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItemGetResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["address"] = this.address;
        data["state"] = this.state;
        data["dateTimeOfOrder"] = this.dateTimeOfOrder ? this.dateTimeOfOrder.toISOString() : <any>undefined;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderGetResponse {
    userName?: string;
    address?: string | undefined;
    state?: OrderState;
    dateTimeOfOrder?: Date;
    orderItems?: OrderItemGetResponse[] | undefined;
}

export class OrderItemGetResponse implements IOrderItemGetResponse {
    id?: string;
    productId?: string;
    productName?: string | undefined;
    quantity?: number;
    pricePerPiece?: number;

    constructor(data?: IOrderItemGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.pricePerPiece = _data["pricePerPiece"];
        }
    }

    static fromJS(data: any): OrderItemGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["pricePerPiece"] = this.pricePerPiece;
        return data; 
    }
}

export interface IOrderItemGetResponse {
    id?: string;
    productId?: string;
    productName?: string | undefined;
    quantity?: number;
    pricePerPiece?: number;
}

export class OrderStateEditCommand implements IOrderStateEditCommand {
    id?: string;
    state?: OrderState;

    constructor(data?: IOrderStateEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): OrderStateEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStateEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        return data; 
    }
}

export interface IOrderStateEditCommand {
    id?: string;
    state?: OrderState;
}

export class OrderAddressEditCommand implements IOrderAddressEditCommand {
    id?: string;
    address?: string | undefined;

    constructor(data?: IOrderAddressEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): OrderAddressEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderAddressEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address;
        return data; 
    }
}

export interface IOrderAddressEditCommand {
    id?: string;
    address?: string | undefined;
}

export class ProductGetResponse implements IProductGetResponse {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    categoryId?: string;
    category?: string | undefined;
    propertyValues?: PropertyValueResponse[] | undefined;
    productSockets?: ProductSocketResponse[] | undefined;
    comments?: CommentResponse[] | undefined;

    constructor(data?: IProductGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"];
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValueResponse.fromJS(item));
            }
            if (Array.isArray(_data["productSockets"])) {
                this.productSockets = [] as any;
                for (let item of _data["productSockets"])
                    this.productSockets!.push(ProductSocketResponse.fromJS(item));
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category;
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        if (Array.isArray(this.productSockets)) {
            data["productSockets"] = [];
            for (let item of this.productSockets)
                data["productSockets"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductGetResponse {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    categoryId?: string;
    category?: string | undefined;
    propertyValues?: PropertyValueResponse[] | undefined;
    productSockets?: ProductSocketResponse[] | undefined;
    comments?: CommentResponse[] | undefined;
}

export class PropertyValueResponse implements IPropertyValueResponse {
    id?: string;
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IPropertyValueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface IPropertyValueResponse {
    id?: string;
    name?: string | undefined;
    value?: string | undefined;
}

export class ProductSocketResponse implements IProductSocketResponse {
    socketId?: string;
    name?: string | undefined;

    constructor(data?: IProductSocketResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socketId = _data["socketId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProductSocketResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSocketResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socketId"] = this.socketId;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProductSocketResponse {
    socketId?: string;
    name?: string | undefined;
}

export class CommentResponse implements ICommentResponse {
    id?: string;
    text?: string | undefined;
    rating?: number | undefined;
    userName?: string | undefined;
    dateTimeOfCreation?: Date;

    constructor(data?: ICommentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.rating = _data["rating"];
            this.userName = _data["userName"];
            this.dateTimeOfCreation = _data["dateTimeOfCreation"] ? new Date(_data["dateTimeOfCreation"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CommentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["rating"] = this.rating;
        data["userName"] = this.userName;
        data["dateTimeOfCreation"] = this.dateTimeOfCreation ? this.dateTimeOfCreation.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICommentResponse {
    id?: string;
    text?: string | undefined;
    rating?: number | undefined;
    userName?: string | undefined;
    dateTimeOfCreation?: Date;
}

export class ProductEditCommand implements IProductEditCommand {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    categoryId?: string;
    propertyValues?: PropertyValueEditCommand[] | undefined;
    productSockets?: ProductSocketEditCommand[] | undefined;

    constructor(data?: IProductEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValueEditCommand.fromJS(item));
            }
            if (Array.isArray(_data["productSockets"])) {
                this.productSockets = [] as any;
                for (let item of _data["productSockets"])
                    this.productSockets!.push(ProductSocketEditCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProductEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        if (Array.isArray(this.productSockets)) {
            data["productSockets"] = [];
            for (let item of this.productSockets)
                data["productSockets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductEditCommand {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    categoryId?: string;
    propertyValues?: PropertyValueEditCommand[] | undefined;
    productSockets?: ProductSocketEditCommand[] | undefined;
}

export class PropertyValueEditCommand implements IPropertyValueEditCommand {
    propertyTypeId?: string;
    value?: string | undefined;

    constructor(data?: IPropertyValueEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyTypeId = _data["propertyTypeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyValueEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValueEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyTypeId"] = this.propertyTypeId;
        data["value"] = this.value;
        return data; 
    }
}

export interface IPropertyValueEditCommand {
    propertyTypeId?: string;
    value?: string | undefined;
}

export class ProductSocketEditCommand implements IProductSocketEditCommand {
    socketId?: string;

    constructor(data?: IProductSocketEditCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socketId = _data["socketId"];
        }
    }

    static fromJS(data: any): ProductSocketEditCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSocketEditCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socketId"] = this.socketId;
        return data; 
    }
}

export interface IProductSocketEditCommand {
    socketId?: string;
}

export class SocketCreateCommand implements ISocketCreateCommand {
    name?: string | undefined;
    categorySockets?: CategorySocketCreateCommand[] | undefined;

    constructor(data?: ISocketCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["categorySockets"])) {
                this.categorySockets = [] as any;
                for (let item of _data["categorySockets"])
                    this.categorySockets!.push(CategorySocketCreateCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SocketCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SocketCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.categorySockets)) {
            data["categorySockets"] = [];
            for (let item of this.categorySockets)
                data["categorySockets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISocketCreateCommand {
    name?: string | undefined;
    categorySockets?: CategorySocketCreateCommand[] | undefined;
}

export class CategorySocketCreateCommand implements ICategorySocketCreateCommand {
    categoryId?: string;

    constructor(data?: ICategorySocketCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CategorySocketCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySocketCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        return data; 
    }
}

export interface ICategorySocketCreateCommand {
    categoryId?: string;
}

export class SocketListResponse implements ISocketListResponse {
    id?: string;
    name?: string | undefined;

    constructor(data?: ISocketListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SocketListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SocketListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ISocketListResponse {
    id?: string;
    name?: string | undefined;
}

export class SocketGetResponse implements ISocketGetResponse {
    id?: string;
    name?: string | undefined;
    categorySockets?: CategorySocketGetResponse2[] | undefined;

    constructor(data?: ISocketGetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["categorySockets"])) {
                this.categorySockets = [] as any;
                for (let item of _data["categorySockets"])
                    this.categorySockets!.push(CategorySocketGetResponse2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SocketGetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SocketGetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.categorySockets)) {
            data["categorySockets"] = [];
            for (let item of this.categorySockets)
                data["categorySockets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISocketGetResponse {
    id?: string;
    name?: string | undefined;
    categorySockets?: CategorySocketGetResponse2[] | undefined;
}

export class CategorySocketGetResponse2 implements ICategorySocketGetResponse2 {
    id?: string;
    categoryId?: string;
    categoryName?: string | undefined;

    constructor(data?: ICategorySocketGetResponse2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
        }
    }

    static fromJS(data: any): CategorySocketGetResponse2 {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySocketGetResponse2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        return data; 
    }
}

export interface ICategorySocketGetResponse2 {
    id?: string;
    categoryId?: string;
    categoryName?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}